{"version":3,"file":"static/preview.ac838770087241ac07b6.bundle.js","sources":["webpack:///./src/common/utils/text.js"],"sourcesContent":["import { distanceInWordsToNow, format } from 'date-fns'\nimport norwayLocale from 'date-fns/locale/nb'\nimport prettyJson from 'json-stringify-pretty-compact'\nimport FuzzySet from 'fuzzyset'\nimport Hypher from 'hypher'\nimport norwegian from 'hyphenation.nb-no'\n\n// captialize\nexport const capitalize = R.replace(/./, R.toUpper)\n\n// hyphenate text\nconst hyphenator_no = new Hypher({ ...norwegian, rightmin: 4, leftmin: 4 })\n\nexport const hyphenate = text => hyphenator_no.hyphenateText(text, 10)\n\n// pretty JSON\nexport const toJson = R.tryCatch(prettyJson, (e, data) =>\n  JSON.stringify(e, Object.getOwnPropertyNames(e)),\n)\n\n// Fuzzy matcher\n// :: ([str], number) -> str -> str\nexport const makeFuzzer = (candidates, cutoff = 0.5) => {\n  const fuzzer = FuzzySet(candidates)\n  return R.either(\n    R.pipe(\n      t => fuzzer.get(t) || [],\n      R.filter(R.propSatisfies(R.lt(cutoff), '0')),\n      R.path([0, 1]),\n    ),\n    R.identity,\n  )\n}\n\n// :: string -> string\n\nconst NBRS = '\\xA0'\nconst WORDJOINER = '\\u2060'\nconst APOSTROPHE = 'ʼ'\n\n// cleanup some markup\nexport const cleanText = R.pipe(\n  R.replace(/“/g, '«'), // left curly quote\n  R.replace(/”/g, '»'), // right curly quote\n  R.replace(/\\b'\\b/g, APOSTROPHE), // ascii apostrophe\n  R.replace(/\\u0092/g, APOSTROPHE), // win 1251 encoding\n  R.replace(/\\B\"(.*?)\"\\B/gu, '«$1»'), // straight quotes\n  R.replace(/--/g, '–'), // en-dash\n  R.replace(/(^|[.:?!] +)[-–] ?\\b/gmu, `$1–${WORDJOINER}${NBRS}`),\n  R.replace(/\\r/g, ''), // no carriage returns\n  R.replace(/\\n{3,}/g, '\\n\\n'), // multi newlines\n)\n\n// :: * -> string\nexport const stringify = R.cond([\n  [R.is(String), R.identity],\n  [R.isNil, R.always('')],\n  [R.T, R.toString],\n])\n\n// like unix `tr` tranlate program\n// :: str -> str -> str -> str\nexport const tr = R.curry((a, b, text) => {\n  const trans = R.zipObj(R.split('', a), R.split('', b))\n  return R.pipe(R.map(l => trans[l] || l), R.join(''))(text)\n})\n\n// :: string -> string\nexport const slugify = R.pipe(\n  R.toLower,\n  R.replace(/['\"]/g, ''),\n  tr('æåàáäâèéëêìíïîòóøöôùúüûñç', 'aaaaaaeeeeiiiiooooouuuunc'),\n  R.replace(/[^a-z0-9]+/g, ' '),\n  R.trim,\n  R.replace(/ +/g, '-'),\n)\n\n// :: int|string -> string\nexport const phoneFormat = R.pipe(\n  stringify,\n  R.trim,\n  R.ifElse(Boolean, R.identity, R.always('–')),\n  R.replace(/ /g, ''),\n  R.replace(/(\\+\\d\\d)?(\\d{3})(\\d{2})(\\d{3})$/, '$1 $2 $3 $4'),\n)\n\n// :: string|Date -> string\nexport const formatDate = (\n  value,\n  dateformat = 'dddd DD. MMM YYYY',\n  locale = norwayLocale,\n  relative = false,\n) =>\n  relative\n    ? distanceInWordsToNow(new Date(value), { addSuffix: true, locale })\n    : format(new Date(value), dateformat, { locale })\n\n// :: number -> string\nconst toFixed = R.curryN(2, (digits, number) => number.toPrecision(digits))\n\n// :: number -> string\nexport const formatFileSize = (size = 0, digits = 3) => {\n  const units = ['B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']\n  const multiple = size ? Math.floor(Math.log10(size) / 3) : 0\n  const number = multiple ? toFixed(digits, size / 10 ** (multiple * 3)) : size\n  const unit = units[multiple]\n  const nbrspace = '\\xA0'\n  return unit ? `${number}${nbrspace}${unit}` : 'very bigly large size'\n}\n\n// Exif utility. Text fields are often encoded in utf8.\n// :: utf-8 encoded string -> unicode string\nexport const utf8Decode = R.when(\n  R.is(String),\n  R.pipe(\n    R.replace(/\\xc5\\x92/g, 'å'), // workaround unknown encoding\n    R.replace(/\\xc2\\xbf/g, 'ø'), // workaround unknown encoding\n    R.tryCatch(R.pipe(escape, decodeURIComponent), R.nthArg(1)),\n    R.trim,\n  ),\n)\n\n// simple text hasher\n// :: string -> number\nexport const hashText = text => {\n  let hash = 0\n  let i = text.length\n  while (i--) hash = ((hash << 5) - hash + text.charCodeAt(i)) << 0\n  return hash\n}\n"],"mappings":"AAAA","sourceRoot":""}