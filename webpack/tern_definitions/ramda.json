{
  "!name": "node_modules/ramda/dist/ramda.js",
  "R": {
    "__": {
      "@@functional/placeholder": {
        "!type": "bool",
        "!span": "1003[35:15]-1029[35:41]"
      },
      "!span": "314782[9140:8]-314784[9140:10]",
      "!doc": "A special placeholder value used to specify \"gaps\" within curried functions,\nallowing partial application of any combination of arguments, regardless of\ntheir positions.\n\nIf `g` is a curried ternary function and `_` is `R.__`, the following are\nequivalent:\n\n  - `g(1, 2, 3)`\n  - `g(_, 2, 3)(1)`\n  - `g(_, _, 3)(1)(2)`\n  - `g(_, _, 3)(1, 2)`\n  - `g(_, 2, _)(1, 3)`\n  - `g(_, 2)(1)(3)`\n  - `g(_, 2)(1, 3)`\n  - `g(_, 2)(_, 3)(1)`\n\n@constant\n@memberOf R\n@since v0.6.0\n@category Function\n@example\n\n     var greet = R.replace('{name}', R.__, 'Hello, {name}!');\n     greet('Alice'); //=> 'Hello, Alice!'"
    },
    "add": {
      "!type": "+Function",
      "!span": "314798[9141:8]-314801[9141:11]"
    },
    "compose": {
      "!type": "fn() -> +Function",
      "!span": "315408[9167:8]-315415[9167:15]",
      "!doc": "Performs right-to-left function composition. The rightmost function may have\nany arity; the remaining functions must be unary.\n\n**Note:** The result of compose is not automatically curried.\n\n@func\n@memberOf R\n@since v0.1.0\n@category Function\n@sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> ((a, b, ..., n) -> z)\n@param {...Function} ...functions The functions to compose\n@return {Function}\n@see R.pipe\n@example\n\n     var classyGreeting = (firstName, lastName) => \"The name's \" + lastName + \", \" + firstName + \" \" + lastName\n     var yellGreeting = R.compose(R.toUpper, classyGreeting);\n     yellGreeting('James', 'Bond'); //=> \"THE NAME'S BOND, JAMES BOND\"\n\n     R.compose(Math.abs, R.add(1), R.multiply(2))(-4) //=> 7\n\n@symb R.compose(f, g, h)(a, b) = f(g(h(a, b)))"
    },
    "composeK": {
      "!type": "fn() -> +Function",
      "!span": "315434[9168:8]-315442[9168:16]",
      "!doc": "Returns the right-to-left Kleisli composition of the provided functions,\neach of which must return a value of a type supported by [`chain`](#chain).\n\n`R.composeK(h, g, f)` is equivalent to `R.compose(R.chain(h), R.chain(g), R.chain(f))`.\n\n@func\n@memberOf R\n@since v0.16.0\n@category Function\n@sig Chain m => ((y -> m z), (x -> m y), ..., (a -> m b)) -> (a -> m z)\n@param {...Function} ...functions The functions to compose\n@return {Function}\n@see R.pipeK\n@example\n\n      //  get :: String -> Object -> Maybe *\n      var get = R.curry((propName, obj) => Maybe(obj[propName]))\n\n      //  getStateCode :: Maybe String -> Maybe String\n      var getStateCode = R.composeK(\n        R.compose(Maybe.of, R.toUpper),\n        get('state'),\n        get('address'),\n        get('user'),\n      );\n      getStateCode({\"user\":{\"address\":{\"state\":\"ny\"}}}); //=> Maybe.Just(\"NY\")\n      getStateCode({}); //=> Maybe.Nothing()\n@symb R.composeK(f, g, h)(a) = R.chain(f, R.chain(g, h(a)))"
    },
    "composeP": {
      "!type": "fn() -> +Function",
      "!span": "315462[9169:8]-315470[9169:16]",
      "!doc": "Performs right-to-left composition of one or more Promise-returning\nfunctions. The rightmost function may have any arity; the remaining\nfunctions must be unary.\n\n@func\n@memberOf R\n@since v0.10.0\n@category Function\n@sig ((y -> Promise z), (x -> Promise y), ..., (a -> Promise b)) -> (a -> Promise z)\n@param {...Function} functions The functions to compose\n@return {Function}\n@see R.pipeP\n@example\n\n     var db = {\n       users: {\n         JOE: {\n           name: 'Joe',\n           followers: ['STEVE', 'SUZY']\n         }\n       }\n     }\n\n     // We'll pretend to do a db lookup which returns a promise\n     var lookupUser = (userId) => Promise.resolve(db.users[userId])\n     var lookupFollowers = (user) => Promise.resolve(user.followers)\n     lookupUser('JOE').then(lookupFollowers)\n\n     //  followersForUser :: String -> Promise [UserId]\n     var followersForUser = R.composeP(lookupFollowers, lookupUser);\n     followersForUser('JOE').then(followers => console.log('Followers:', followers))\n     // Followers: [\"STEVE\",\"SUZY\"]"
    },
    "pipe": {
      "!type": "fn() -> +Function",
      "!span": "318848[9300:8]-318852[9300:12]",
      "!doc": "Performs left-to-right function composition. The leftmost function may have\nany arity; the remaining functions must be unary.\n\nIn some libraries this function is named `sequence`.\n\n**Note:** The result of pipe is not automatically curried.\n\n@func\n@memberOf R\n@since v0.1.0\n@category Function\n@sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)\n@param {...Function} functions\n@return {Function}\n@see R.compose\n@example\n\n     var f = R.pipe(Math.pow, R.negate, R.inc);\n\n     f(3, 4); // -(3^4) + 1\n@symb R.pipe(f, g, h)(a, b) = h(g(f(a, b)))"
    },
    "pipeK": {
      "!type": "fn() -> +Function",
      "!span": "318868[9301:8]-318873[9301:13]",
      "!doc": "Returns the left-to-right Kleisli composition of the provided functions,\neach of which must return a value of a type supported by [`chain`](#chain).\n\n`R.pipeK(f, g, h)` is equivalent to `R.pipe(R.chain(f), R.chain(g), R.chain(h))`.\n\n@func\n@memberOf R\n@since v0.16.0\n@category Function\n@sig Chain m => ((a -> m b), (b -> m c), ..., (y -> m z)) -> (a -> m z)\n@param {...Function}\n@return {Function}\n@see R.composeK\n@example\n\n     //  parseJson :: String -> Maybe *\n     //  get :: String -> Object -> Maybe *\n\n     //  getStateCode :: Maybe String -> Maybe String\n     var getStateCode = R.pipeK(\n       parseJson,\n       get('user'),\n       get('address'),\n       get('state'),\n       R.compose(Maybe.of, R.toUpper)\n     );\n\n     getStateCode('{\"user\":{\"address\":{\"state\":\"ny\"}}}');\n     //=> Just('NY')\n     getStateCode('[Invalid JSON]');\n     //=> Nothing()\n@symb R.pipeK(f, g, h)(a) = R.chain(h, R.chain(g, f(a)))"
    },
    "pipeP": {
      "!type": "fn() -> +Function",
      "!span": "318890[9302:8]-318895[9302:13]",
      "!doc": "Performs left-to-right composition of one or more Promise-returning\nfunctions. The leftmost function may have any arity; the remaining functions\nmust be unary.\n\n@func\n@memberOf R\n@since v0.10.0\n@category Function\n@sig ((a -> Promise b), (b -> Promise c), ..., (y -> Promise z)) -> (a -> Promise z)\n@param {...Function} functions\n@return {Function}\n@see R.composeP\n@example\n\n     //  followersForUser :: String -> Promise [User]\n     var followersForUser = R.pipeP(db.getUserById, db.getFollowers);"
    },
    "!span": "321226[9394:9]-321227[9394:10]",
    "addIndex": "+Function",
    "adjust": "+Function",
    "all": "+Function",
    "allPass": "+Function",
    "always": "+Function",
    "and": "+Function",
    "any": "+Function",
    "anyPass": "+Function",
    "ap": "+Function",
    "aperture": "+Function",
    "append": "+Function",
    "apply": "+Function",
    "applySpec": "+Function",
    "ascend": "+Function",
    "assoc": "+Function",
    "assocPath": "+Function",
    "binary": "+Function",
    "bind": "+Function",
    "both": "+Function",
    "chain": "+Function",
    "clamp": "+Function",
    "clone": "+Function",
    "comparator": "+Function",
    "concat": "+Function",
    "cond": "+Function",
    "construct": "+Function",
    "constructN": "+Function",
    "contains": "+Function",
    "converge": "+Function",
    "curry": "+Function",
    "curryN": "+Function",
    "dec": "+Function",
    "defaultTo": "+Function",
    "descend": "+Function",
    "difference": "+Function",
    "differenceWith": "+Function",
    "dissoc": "+Function",
    "dissocPath": "+Function",
    "divide": "+Function",
    "drop": "+Function",
    "dropLast": "+Function",
    "dropLastWhile": "+Function",
    "dropRepeats": "+Function",
    "dropRepeatsWith": "+Function",
    "dropWhile": "+Function",
    "either": "+Function",
    "empty": "+Function",
    "endsWith": "+Function",
    "eqBy": "+Function",
    "eqProps": "+Function",
    "equals": "+Function",
    "evolve": "+Function",
    "filter": "+Function",
    "find": "+Function",
    "findIndex": "+Function",
    "findLast": "+Function",
    "findLastIndex": "+Function",
    "flatten": "+Function",
    "flip": "+Function",
    "forEach": "+Function",
    "forEachObjIndexed": "+Function",
    "fromPairs": "+Function",
    "groupBy": "+Function",
    "groupWith": "+Function",
    "gt": "+Function",
    "gte": "+Function",
    "has": "+Function",
    "hasIn": "+Function",
    "head": "+Function",
    "identical": "+Function",
    "identity": "+Function",
    "ifElse": "+Function",
    "inc": "+Function",
    "indexOf": "+Function",
    "init": "+Function",
    "innerJoin": "+Function",
    "insert": "+Function",
    "insertAll": "+Function",
    "intersection": "+Function",
    "intersectionWith": "+Function",
    "intersperse": "+Function",
    "into": "+Function",
    "invert": "+Function",
    "invertObj": "+Function",
    "invoker": "+Function",
    "is": "+Function",
    "isEmpty": "+Function",
    "isNil": "+Function",
    "join": "+Function",
    "juxt": "+Function",
    "keys": "+Function",
    "keysIn": "+Function",
    "last": "+Function",
    "lastIndexOf": "+Function",
    "length": "+Function",
    "lens": "+Function",
    "lensIndex": "+Function",
    "lensPath": "+Function",
    "lensProp": "+Function",
    "lift": "+Function",
    "liftN": "+Function",
    "lt": "+Function",
    "lte": "+Function",
    "map": "+Function",
    "mapAccum": "+Function",
    "mapAccumRight": "+Function",
    "mapObjIndexed": "+Function",
    "match": "+Function",
    "mathMod": "+Function",
    "max": "+Function",
    "maxBy": "+Function",
    "mean": "+Function",
    "median": "+Function",
    "memoize": "+Function",
    "memoizeWith": "+Function",
    "merge": "+Function",
    "mergeAll": "+Function",
    "mergeDeepLeft": "+Function",
    "mergeDeepRight": "+Function",
    "mergeDeepWith": "+Function",
    "mergeDeepWithKey": "+Function",
    "mergeWith": "+Function",
    "mergeWithKey": "+Function",
    "min": "+Function",
    "minBy": "+Function",
    "modulo": "+Function",
    "multiply": "+Function",
    "nAry": "+Function",
    "negate": "+Function",
    "none": "+Function",
    "not": "+Function",
    "nth": "+Function",
    "nthArg": "+Function",
    "o": "+Function",
    "objOf": "+Function",
    "of": "+Function",
    "omit": "+Function",
    "once": "+Function",
    "or": "+Function",
    "over": "+Function",
    "pair": "+Function",
    "partial": "+Function",
    "partialRight": "+Function",
    "path": "+Function",
    "pathEq": "+Function",
    "pathOr": "+Function",
    "pathSatisfies": "+Function",
    "pick": "+Function",
    "pickAll": "+Function",
    "pickBy": "+Function",
    "pluck": "+Function",
    "prepend": "+Function",
    "product": "+Function",
    "project": "+Function",
    "prop": "+Function",
    "propEq": "+Function",
    "propIs": "+Function",
    "propOr": "+Function",
    "propSatisfies": "+Function",
    "props": "+Function",
    "range": "+Function",
    "reduce": "+Function",
    "reduceBy": "+Function",
    "reduceRight": "+Function",
    "reduceWhile": "+Function",
    "reduced": "+Function",
    "reject": "+Function",
    "remove": "+Function",
    "repeat": "+Function",
    "replace": "+Function",
    "reverse": "+Function",
    "scan": "+Function",
    "sequence": "+Function",
    "set": "+Function",
    "slice": "+Function",
    "sort": "+Function",
    "sortBy": "+Function",
    "sortWith": "+Function",
    "split": "+Function",
    "splitAt": "+Function",
    "splitEvery": "+Function",
    "splitWhen": "+Function",
    "startsWith": "+Function",
    "subtract": "+Function",
    "sum": "+Function",
    "symmetricDifference": "+Function",
    "symmetricDifferenceWith": "+Function",
    "tail": "+Function",
    "take": "+Function",
    "takeLast": "+Function",
    "takeLastWhile": "+Function",
    "takeWhile": "+Function",
    "tap": "+Function",
    "test": "+Function",
    "times": "+Function",
    "toLower": "+Function",
    "toPairs": "+Function",
    "toPairsIn": "+Function",
    "toString": "+Function",
    "toUpper": "+Function",
    "transduce": "+Function",
    "transpose": "+Function",
    "traverse": "+Function",
    "trim": "+Function",
    "tryCatch": "+Function",
    "type": "+Function",
    "unapply": "+Function",
    "unary": "+Function",
    "uncurryN": "+Function",
    "unfold": "+Function",
    "union": "+Function",
    "unionWith": "+Function",
    "uniq": "+Function",
    "uniqBy": "+Function",
    "uniqWith": "+Function",
    "unless": "+Function",
    "unnest": "+Function",
    "until": "+Function",
    "update": "+Function",
    "useWith": "+Function",
    "values": "+Function",
    "valuesIn": "+Function",
    "view": "+Function",
    "when": "+Function",
    "where": "+Function",
    "whereEq": "+Function",
    "without": "+Function",
    "xprod": "+Function",
    "zip": "+Function",
    "zipObj": "+Function",
    "zipWith": "+Function"
  }
}
